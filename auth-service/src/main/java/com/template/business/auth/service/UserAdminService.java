package com.template.business.auth.service;

import com.template.business.auth.dto.PageResponse;
import com.template.business.auth.dto.SearchRequest;
import com.template.business.auth.dto.UserAdminDTO;
import com.template.business.auth.dto.UserRoleAssignRequest;
import com.template.business.auth.dto.UserStatusUpdateRequest;
import com.template.business.auth.dto.UserUpdateRequest;
import com.template.business.auth.entity.ApplicationEntity;
import com.template.business.auth.entity.Role;
import com.template.business.auth.entity.User;
import com.template.business.auth.entity.UserRole;
import com.template.business.auth.exception.CustomAuthorizationException;
import com.template.business.auth.exception.CustomValidationException;
import com.template.business.auth.exception.ErrorCode;
import com.template.business.auth.exception.ResourceNotFoundException;
import com.template.business.auth.repository.EntityRepository;
import com.template.business.auth.repository.RoleRepository;
import com.template.business.auth.repository.UserRepository;
import com.template.business.auth.repository.UserRoleRepository;
import com.template.business.auth.util.SpecificationBuilder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service for user administration (ADMIN only)
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class UserAdminService {

    private final UserRepository userRepository;
    private final UserRoleRepository userRoleRepository;
    private final RoleRepository roleRepository;
    private final EntityRepository entityRepository;
    private final PasswordEncoder passwordEncoder;

    /**
     * Create new user (admin)
     */
    @Transactional
    public UserAdminDTO createUser(UserUpdateRequest request) {
        // Check if username already exists
        if (request.getUsername() == null || request.getUsername().trim().isEmpty()) {
            throw new CustomValidationException("Username is required");
        }

        if (userRepository.findByUsername(request.getUsername()).isPresent()) {
            throw new CustomValidationException("Username already exists: " + request.getUsername());
        }

        // Use provided password or generate temporary one
        String password = request.getPassword();
        boolean isAutoGenerated = false;
        if (password == null || password.trim().isEmpty()) {
            password = UUID.randomUUID().toString().substring(0, 12);
            isAutoGenerated = true;
        }

        // Create new user
        User user = new User();
        user.setUsername(request.getUsername());
        user.setPassword(passwordEncoder.encode(password));
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setEmail(request.getEmail());
        user.setCompany(request.getCompany());
        user.setStatus("ACTIVE");
        user.setTheme(request.getTheme() != null ? request.getTheme() : "light");
        user.setPaletteId(request.getPaletteId() != null ? request.getPaletteId() : "ocean-blue");
        user.setCreateDate(new Date());
        user.setCreateUser(SecurityContextHolder.getContext().getAuthentication().getName());

        User savedUser = userRepository.save(user);

        if (isAutoGenerated) {
            log.info("Admin created new user: {} with auto-generated password", request.getUsername());
            log.warn("TEMP PASSWORD for {}: {}", request.getUsername(), password);
        } else {
            log.info("Admin created new user: {} with custom password", request.getUsername());
        }

        return convertToDTO(savedUser);
    }

    /**
     * Reset user password
     * @param username the username
     * @param newPassword optional - if null, generates temporary password
     * @return the password (only if auto-generated, otherwise returns null for security)
     */
    @Transactional
    public String resetPassword(String username, String newPassword) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND));

        String passwordToSet = newPassword;
        boolean isAutoGenerated = false;

        // If no password provided, generate temporary one
        if (passwordToSet == null || passwordToSet.trim().isEmpty()) {
            passwordToSet = UUID.randomUUID().toString().substring(0, 12);
            isAutoGenerated = true;
        }

        user.setPassword(passwordEncoder.encode(passwordToSet));
        userRepository.save(user);

        if (isAutoGenerated) {
            log.info("Admin reset password for user: {} with auto-generated password", username);
            // Note: Temp password is returned via API response, NOT logged for security
            return passwordToSet; // Return temp password
        } else {
            log.info("Admin set custom password for user: {}", username);
            return null; // Don't return custom password for security
        }
    }

    /**
     * Get all users
     */
    public List<UserAdminDTO> getAllUsers() {
        List<User> users = userRepository.findAll();
        return users.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Search users with pagination, filtering, and sorting
     */
    public PageResponse<UserAdminDTO> searchUsers(SearchRequest request) {
        Specification<User> spec = SpecificationBuilder.buildSpecification(request);
        Sort sort = buildSort(request.getSort());
        Pageable pageable = PageRequest.of(request.getPage(), request.getPageSize(), sort);

        Page<User> page = userRepository.findAll(spec, pageable);
        Page<UserAdminDTO> dtoPage = page.map(this::convertToDTO);

        return PageResponse.of(dtoPage);
    }

    private Sort buildSort(SearchRequest.SortInfo sortInfo) {
        if (sortInfo == null || sortInfo.getColumn() == null || sortInfo.getColumn().isEmpty()) {
            return Sort.by(Sort.Direction.ASC, "username");
        }
        Sort.Direction direction = "desc".equalsIgnoreCase(sortInfo.getOrder())
                ? Sort.Direction.DESC
                : Sort.Direction.ASC;
        return Sort.by(direction, sortInfo.getColumn());
    }

    /**
     * Get user by username
     */
    public UserAdminDTO getUserByUsername(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND));
        return convertToDTO(user);
    }

    /**
     * Update user details (admin)
     */
    @Transactional
    public UserAdminDTO updateUser(String username, UserUpdateRequest request) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND));

        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setEmail(request.getEmail());

        if (request.getCompany() != null) {
            user.setCompany(request.getCompany());
        }
        if (request.getTheme() != null) {
            user.setTheme(request.getTheme());
        }
        if (request.getPaletteId() != null) {
            user.setPaletteId(request.getPaletteId());
        }

        User updatedUser = userRepository.save(user);
        log.info("Admin updated user: {}", username);

        return convertToDTO(updatedUser);
    }

    /**
     * Update user status (activate/deactivate)
     */
    @Transactional
    public UserAdminDTO updateUserStatus(String username, UserStatusUpdateRequest request) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND));

        // Prevent admin from deactivating themselves
        String currentUsername = SecurityContextHolder.getContext().getAuthentication().getName();
        if (username.equals(currentUsername) && "INACTIVE".equals(request.getStatus())) {
            throw new CustomAuthorizationException(ErrorCode.UNAUTHORIZED_SESSION_ACCESS,
                    "Cannot deactivate your own account");
        }

        user.setStatus(request.getStatus());
        User updatedUser = userRepository.save(user);

        log.info("Admin changed user {} status to: {}", username, request.getStatus());

        return convertToDTO(updatedUser);
    }

    /**
     * Get user roles
     */
    public List<UserAdminDTO.UserRoleDTO> getUserRoles(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND));

        return user.getUserRoles().stream()
                .map(ur -> UserAdminDTO.UserRoleDTO.builder()
                        .role(ur.getId().getRole())
                        .entity(ur.getId().getEntity())
                        .description(ur.getRole() != null ? ur.getRole().getDescription() : null)
                        .status(ur.getStatus())
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Assign role to user
     */
    @Transactional
    public void assignRoleToUser(String username, UserRoleAssignRequest request) {
        // Check if user exists
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND));

        // Check if role exists
        Role role = roleRepository.findByIdRoleAndIdEntity(request.getRole(), request.getEntity())
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.ROLE_NOT_FOUND,
                        "Role not found: " + request.getRole() + " for entity: " + request.getEntity()));

        // Check if user already has this role
        UserRole.UserRoleId userRoleId = new UserRole.UserRoleId(username, request.getRole(), request.getEntity());
        if (userRoleRepository.existsById(userRoleId)) {
            throw new CustomAuthorizationException(ErrorCode.UNAUTHORIZED_SESSION_ACCESS,
                    "User already has this role");
        }

        // Create user-role assignment
        UserRole userRole = new UserRole();
        userRole.setId(userRoleId);
        userRole.setStatus("ACTIVE");
        userRole.setCreateDate(new Date());
        userRole.setCreateUser(SecurityContextHolder.getContext().getAuthentication().getName());

        userRoleRepository.save(userRole);
        log.info("Admin assigned role {} (entity: {}) to user: {}", request.getRole(), request.getEntity(), username);
    }

    /**
     * Remove role from user
     */
    @Transactional
    public void removeRoleFromUser(String username, String role, String entity) {
        UserRole.UserRoleId userRoleId = new UserRole.UserRoleId(username, role, entity);
        UserRole userRole = userRoleRepository.findById(userRoleId)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.ROLE_NOT_FOUND,
                        "User does not have this role"));

        // Prevent removing admin role from yourself
        String currentUsername = SecurityContextHolder.getContext().getAuthentication().getName();
        if (username.equals(currentUsername) && "ADMIN".equals(role)) {
            throw new CustomAuthorizationException(ErrorCode.UNAUTHORIZED_SESSION_ACCESS,
                    "Cannot remove your own admin role");
        }

        userRoleRepository.delete(userRole);
        log.info("Admin removed role {} (entity: {}) from user: {}", role, entity, username);
    }

    /**
     * Delete user (admin)
     */
    @Transactional
    public void deleteUser(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND));

        // Prevent admin from deleting themselves
        String currentUsername = SecurityContextHolder.getContext().getAuthentication().getName();
        if (username.equals(currentUsername)) {
            throw new CustomAuthorizationException(ErrorCode.UNAUTHORIZED_SESSION_ACCESS,
                    "Cannot delete your own account");
        }

        userRepository.delete(user);
        log.info("Admin deleted user: {}", username);
    }

    /**
     * Convert User entity to UserAdminDTO
     */
    private UserAdminDTO convertToDTO(User user) {
        List<UserAdminDTO.UserRoleDTO> roles = user.getUserRoles().stream()
                .map(ur -> {
                    // Get entity name from the Role's ApplicationEntity relationship or lookup
                    String entityName = null;
                    if (ur.getRole() != null && ur.getRole().getEntity() != null) {
                        entityName = ur.getRole().getEntity().getName();
                    } else {
                        // Fallback: lookup entity by ID if relationship not loaded
                        entityName = entityRepository.findById(ur.getId().getEntity())
                                .map(ApplicationEntity::getName)
                                .orElse(ur.getId().getEntity()); // Fallback to ID if not found
                    }

                    return UserAdminDTO.UserRoleDTO.builder()
                            .role(ur.getId().getRole())
                            .entity(ur.getId().getEntity())
                            .entityName(entityName)
                            .description(ur.getRole() != null ? ur.getRole().getDescription() : null)
                            .status(ur.getStatus())
                            .build();
                })
                .collect(Collectors.toList());

        return UserAdminDTO.builder()
                .username(user.getUsername())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .email(user.getEmail())
                .company(user.getCompany())
                .status(user.getStatus())
                .theme(user.getTheme())
                .paletteId(user.getPaletteId())
                .createDate(user.getCreateDate())
                .createUser(user.getCreateUser())
                .roles(roles)
                .build();
    }
}
